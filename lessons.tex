
\subsection*{7.1 Nate Brennand}

Failure to stick to a strict weekly team meeting made it difficult to get consistent work done by the group at large.
We made a plan that 1 â€“ 2 members would write out the first section of the compiler pipeline.
This worked well, but it should have been completed at an earlier date to give others more time to ramp up with the project.
The late ramp up in work on the project created issues with code generation because we chose a target language that only one group member had experience with.
In retrospect, we could (and should) have transitioned to a more common language, Java, that we all had familiarity with.

\subsection*{7.2 Ben Edelstein}

As this was the first large team project I have worked on, I probably learned as much from my teammates as I did from the subject matter. Using a continuous integration platform as well as enforcing code reviews seemed excessive at the beginning of the project, but I quickly learned that these actually made it much easier to develop. Writing separate tests for the different stages of the compiler was also very helpful since it made it easy to introduce a new feature on stage at a time.


\subsection*{7.3 Brendan Fish}

\subsection*{7.4 Dan Schlosser}

Our LRM was too ambitious.  As the language guru for RAPID, it was my job to make
sure we were keeping true to our vision of the language, so I felt the conflict
between what we wanted to implement and what we could feasibly implement very
often.  Narrowing our scope would have allowed us set better goals that would be
more achievable within the span of one semester.

Throughout working on this project I learned a lot about both OCaml and Go.  I
appreciate the experience of learning two new languages at once, but in
retrospect, choosing Go as our destination language was not ideal.  Because of
how Go's primitives work, there were a lot of compromises that we had to make
in order to have reasonable output at the end of our project.

\subsection*{7.5 Brian Shin}
Code review and a robust testing frameworks were very important in catching bugs and regressions in the code.
Our team did not have or enforce milestones for the project, leading development to be very compressed towards the end of the project.
Translating code from RAPID (with nullable primatives) to Go (without nullable primatives) proved to be more difficult than expected, which slowed down code generation.

