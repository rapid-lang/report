
\subsection*{Nate Brennand}

Failure to stick to a strict weekly team meeting made it difficult to get consistent work done by the group at large.
We made a plan that 1 \- 2 members would write out the first section of the compiler pipeline.
This worked well, but it should have been completed at an earlier date to give others more time to ramp up with the project.
The late ramp up in work on the project created issues with code generation because we chose a target language that only one group member had experience with.
In retrospect, we could (and should) have transitioned to a more common language, Java, that we all had familiarity with.

\subsection*{Brian Shin}

Code review and a robust testing frameworks were very important in catching bugs and regressions in the code.
Our team did not have or enforce milestones for the project, leading development to be very compressed towards the end of the project.
Translating code from RAPID (with nullable primatives) to Go (without nullable primatives) proved to be more difficult than expected, which slowed down code generation.


\subsection*{Ben Edelstein}

As this was the first large team project I have worked on, I probably learned as much from my teammates as I did from the subject matter. Using a continuous integration platform as well as enforcing code reviews seemed excessive at the beginning of the project, but I quickly learned that these actually made it much easier to develop. Writing separate tests for the different stages of the compiler was also very helpful since it made it easy to introduce a new feature on stage at a time.